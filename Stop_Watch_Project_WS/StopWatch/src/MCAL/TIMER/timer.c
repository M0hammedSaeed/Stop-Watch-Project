/*******************************************************************************
 *
 *  [   Module  ]: Timer's Modules
 *
 *  [ File Name ]: timer.c
 *
 *  [Description]: Source File For AVR_Timer Module.
 *
 *  [   Author  ]: Mohamed Saeed
 *
 *******************************************************************************/

/*******************************************************************************
 *                                  INCLUDES
 *******************************************************************************/

#include "timer.h"
#include "timer_private.h"
#include "../GPIO/gpio.h"
#include "../../utils/common_macros.h"

/*******************************************************************************
 *                               Global Variable
 *******************************************************************************/

/*
 * [Description]: Pointer To Function Save the Address Of The function
 *                That will called when Event or interrupt occur .
 *            ==> AND Every Timer have Pointer To g_Function .
 */
static volatile void(*g_Ptr_To_Fun_TIMER_0)(void)= NULL_PTR;
static volatile void(*g_Ptr_To_Fun_TIMER_1)(void)= NULL_PTR;
static volatile void(*g_Ptr_To_Fun_TIMER_2)(void)= NULL_PTR;

volatile uint8 interruptSecondFlag = FALSE;

/*******************************************************************************
 *                                 TIMER0_ISR
 *******************************************************************************/

/*
 * [Description]: The ISR's specific For TIMER0
 */
ISR(TIMER0_OVF_vect)
{
	/* Call the Call Back function in the application after the Event is Occur */
	if(g_Ptr_To_Fun_TIMER_0 != NULL_PTR)
	{
		/* This is called --> Call Back Notification */
		/* another method to call the function using pointer to function g_Ptr_To_Fun_0(); */
		(*g_Ptr_To_Fun_TIMER_0)();
	}
}

ISR(TIMER0_COMP_vect)
{
	if(g_Ptr_To_Fun_TIMER_0 != NULL_PTR)
	{
		(*g_Ptr_To_Fun_TIMER_0)();
	}
}

/*******************************************************************************
 *                                 TIMER1_ISR
 *******************************************************************************/

/*
 * [Description]: The ISR's specific For TIMER1
 */
ISR(TIMER1_OVF_vect)
{
	if(g_Ptr_To_Fun_TIMER_1 != NULL_PTR)
	{
		(*g_Ptr_To_Fun_TIMER_1)();
	}
}

ISR(TIMER1_COMPA_vect)
{
	interruptSecondFlag = TRUE;

	if(g_Ptr_To_Fun_TIMER_1 != NULL_PTR)
	{
		(*g_Ptr_To_Fun_TIMER_1)();
	}
}

ISR(TIMER1_COMPB_vect)
{
	if(g_Ptr_To_Fun_TIMER_1 != NULL_PTR)
	{
		(*g_Ptr_To_Fun_TIMER_1)();
	}
}

/*******************************************************************************
 *                                 TIMER2_ISR
 *******************************************************************************/

/*
 * [Description]: The ISR's specific For TIMER1
 */
ISR(TIMER2_OVF_vect)
{
	if(g_Ptr_To_Fun_TIMER_2 != NULL_PTR)
	{
		(*g_Ptr_To_Fun_TIMER_2)();
	}
}

ISR(TIMER2_COMP_vect)
{
	if(g_Ptr_To_Fun_TIMER_2 != NULL_PTR)
	{
		(*g_Ptr_To_Fun_TIMER_0)();
	}
}



/*******************************************************************************
 *                         Implementation FUNCTIONS
 *******************************************************************************/

/*
 * [FUNCTION NAME]: TIMER_Init
 * [DISCRIPTION]  : This function is responsible to initialization one or more than one timer at
 *                  The same time from Configuration of timer .
 * [Args]  : void
 * [RUTURN]: Void
 */
void TIMER_Init(void)
{
#if TIMER0 == ENABLE
#if (TIMER0_MODE_SELECTOR == TIMER0_MODE_PWM_PHASECORRECT_MSK) || (TIMER0_MODE_SELECTOR == TIMER0_MODE_FASTPWM_MSK)
#if (TIMER0_MODE_SELECTOR == TIMER0_MODE_PWM_PHASECORRECT_MSK)
	TCCR0_REG &= TIMER0_MODE_clr_MSK;
	TCCR0_REG |= TIMER0_MODE_PWM_PHASECORRECT_MSK;
#elif (TIMER0_MODE_SELECTOR == TIMER0_MODE_FASTPWM_MSK)
	TCCR0_REG &= TIMER0_MODE_clr_MSK;
	TCCR0_REG |= TIMER0_MODE_FASTPWM_MSK;
#endif

#if TIMER0_OC0_BEHAVIOR_SELECTOR == TIMER0_OC0_NON_INVERTING_MSK
	TCCR0_REG &= TIMER0_OC0_clr_MSK;
	GPIO_SetPinDir(TIMER0_OC0_PORT, TIMER0_OC0_Pin, pin_output);
	TCCR0_REG |= TIMER0_OC0_NON_INVERTING_MSK;
#elif TIMER0_OC0_BEHAVIOR_SELECTOR == TIMER0_OC0_INVERTING_MSK
	TCCR0_REG &= TIMER0_OC0_clr_MSK;
	GPIO_SetPinDir(TIMER0_OC0_PORT, TIMER0_OC0_Pin, pin_output);
	TCCR0_REG |= TIMER0_OC0_INVERTING_MSK;
#endif
#endif

#if (TIMER0_MODE_SELECTOR == TIMER0_MODE_OVF_MSK) || (TIMER0_MODE_SELECTOR == TIMER0_MODE_CTC_MSK)
#if TIMER0_MODE_SELECTOR == TIMER0_MODE_OVF_MSK
	TCCR0_REG &= TIMER0_MODE_clr_MSK;
	TCCR0_REG |= TIMER0_MODE_OVF_MSK;
#elif TIMER0_MODE_SELECTOR == TIMER0_MODE_CTC_MSK
	TCCR0_REG &= TIMER0_MODE_clr_MSK;
	TCCR0_REG |= TIMER0_MODE_CTC_MSK;
#endif

#if TIMER0_OC0_BEHAVIOR_SELECTOR == TIMER0_OC0_TOGGLE_MSK
	TCCR0_REG &= TIMER0_OC0_clr_MSK;
	GPIO_SetPinDir(TIMER0_OC0_PORT, TIMER0_OC0_Pin, pin_output);
	TCCR0_REG |= TIMER0_OC0_TOGGLE_MSK;
#elif TIMER0_OC0_BEHAVIOR_SELECTOR == TIMER0_OC0_CLR_MSK
	TCCR0_REG &= TIMER0_OC0_clr_MSK;
	GPIO_SetPinDir(TIMER0_OC0_PORT, TIMER0_OC0_Pin, pin_output);
	TCCR0_REG |= TIMER0_OC0_CLR_MSK;
#elif TIMER0_OC0_BEHAVIOR_SELECTOR == TIMER0_OC0_SET_MSK
	TCCR0_REG &= TIMER0_OC0_clr_MSK;
	GPIO_SetPinDir(TIMER0_OC0_PORT, TIMER0_OC0_Pin, pin_output);
	TCCR0_REG |= TIMER0_OC0_SET_MSK;
#endif
#endif

	switch(TIMER0_PRESCALER_SELECTOR)
	{
	case TIMER0_CLK_WITH_NO_PRESCALER_MSK:
		TCCR0_REG &= TIMER0_CLK_WITH_PRESCALER_clr_MSK;
		TCCR0_REG |= TIMER0_CLK_WITH_NO_PRESCALER_MSK;
		break;
	case TIMER0_CLK_WITH_8_PRESCALER_MSK:
		TCCR0_REG &= TIMER0_CLK_WITH_PRESCALER_clr_MSK;
		TCCR0_REG |= TIMER0_CLK_WITH_8_PRESCALER_MSK;
		break;
	case TIMER0_CLK_WITH_64_PRESCALER_MSK:
		TCCR0_REG &= TIMER0_CLK_WITH_PRESCALER_clr_MSK;
		TCCR0_REG |= TIMER0_CLK_WITH_64_PRESCALER_MSK;
		break;
	case TIMER0_CLK_WITH_256_PRESCALER_MSK:
		TCCR0_REG &= TIMER0_CLK_WITH_PRESCALER_clr_MSK;
		TCCR0_REG |= TIMER0_CLK_WITH_256_PRESCALER_MSK;
		break;
	case TIMER0_CLK_WITH_1024_PRESCALER_MSK:
		TCCR0_REG &= TIMER0_CLK_WITH_PRESCALER_clr_MSK;
		TCCR0_REG |= TIMER0_CLK_WITH_1024_PRESCALER_MSK;
		break;
	case TIMER0_EXTERNAL_CLK_WITH_FALLING_EDGE_MSK:
		TCCR0_REG &= TIMER0_CLK_WITH_PRESCALER_clr_MSK;
		TCCR0_REG |= TIMER0_EXTERNAL_CLK_WITH_FALLING_EDGE_MSK;
		break;
	case TIMER0_EXTERNAL_CLK_WITH_RISING_EDGE_MSK:
		TCCR0_REG &= TIMER0_CLK_WITH_PRESCALER_clr_MSK;
		TCCR0_REG |= TIMER0_EXTERNAL_CLK_WITH_RISING_EDGE_MSK;
		break;
	}

	/* Initial value for Timer/Counter0 */
	TCNT0_REG = TIMER0_INITIAL_VALUE;

	/* Compare value for Timer/Counter0 */
	OCR0_REG = TIMER0_COMPARE_VALUE;
#endif


#if TIMER1 == ENABLE

	switch(TIMER1_MODE_SELECTOR)
	{
	case TIMER1_MODE_OVF_MSK:
		TCCR1A_REG &= TIMER1_MODE_clr_A_MSK;
		TCCR1B_REG &= TIMER1_MODE_clr_B_MSK;

		TCCR1A_REG |= TIMER1_MODE_OVF_A_MSK;
		TCCR1B_REG |= TIMER1_MODE_OVF_B_MSK;
		break;
	case TIMER1_MODE_PWM_PHASECORRECT_8_BIT_MSK:
		TCCR1A_REG &= TIMER1_MODE_clr_A_MSK;
		TCCR1B_REG &= TIMER1_MODE_clr_B_MSK;

		TCCR1A_REG |= TIMER1_MODE_PWM_PHASECORRECT_8_BIT_A_MSK;
		TCCR1B_REG |= TIMER1_MODE_PWM_PHASECORRECT_8_BIT_B_MSK;
		break;
	case TIMER1_MODE_PWM_PHASECORRECT_9_BIT_MSK:
		TCCR1A_REG &= TIMER1_MODE_clr_A_MSK;
		TCCR1B_REG &= TIMER1_MODE_clr_B_MSK;

		TCCR1A_REG |= TIMER1_MODE_PWM_PHASECORRECT_9_BIT_A_MSK;
		TCCR1B_REG |= TIMER1_MODE_PWM_PHASECORRECT_9_BIT_B_MSK;
		break;
	case TIMER1_MODE_PWM_PHASECORRECT_10_BIT_MSK:
		TCCR1A_REG &= TIMER1_MODE_clr_A_MSK;
		TCCR1B_REG &= TIMER1_MODE_clr_B_MSK;

		TCCR1A_REG |= TIMER1_MODE_PWM_PHASECORRECT_10_BIT_A_MSK;
		TCCR1B_REG |= TIMER1_MODE_PWM_PHASECORRECT_10_BIT_B_MSK;
		break;
	case TIMER1_MODE_CTC_MSK:
		TCCR1A_REG &= TIMER1_MODE_clr_A_MSK;
		TCCR1B_REG &= TIMER1_MODE_clr_B_MSK;

		TCCR1A_REG |= TIMER1_MODE_CTC_A_MSK;
		TCCR1B_REG |= TIMER1_MODE_CTC_B_MSK;
		break;
	case TIMER1_MODE_FASTPWM_8_BIT_MSK:
		TCCR1A_REG &= TIMER1_MODE_clr_A_MSK;
		TCCR1B_REG &= TIMER1_MODE_clr_B_MSK;

		TCCR1A_REG |= TIMER1_MODE_FASTPWM_8_BIT_A_MSK;
		TCCR1B_REG |= TIMER1_MODE_FASTPWM_8_BIT_B_MSK;
		break;
	case TIMER1_MODE_FASTPWM_9_BIT_MSK:
		TCCR1A_REG &= TIMER1_MODE_clr_A_MSK;
		TCCR1B_REG &= TIMER1_MODE_clr_B_MSK;

		TCCR1A_REG |= TIMER1_MODE_FASTPWM_9_BIT_A_MSK;
		TCCR1B_REG |= TIMER1_MODE_FASTPWM_9_BIT_B_MSK;
		break;
	case TIMER1_MODE_FASTPWM_10_BIT_MSK:
		TCCR1A_REG &= TIMER1_MODE_clr_A_MSK;
		TCCR1B_REG &= TIMER1_MODE_clr_B_MSK;

		TCCR1A_REG |= TIMER1_MODE_FASTPWM_10_BIT_A_MSK;
		TCCR1B_REG |= TIMER1_MODE_FASTPWM_10_BIT_B_MSK;
		break;
	case TIMER1_MODE_PWM_PHASE_FREQUENCY_CORRECT_MSK:
		TCCR1A_REG &= TIMER1_MODE_clr_A_MSK;
		TCCR1B_REG &= TIMER1_MODE_clr_B_MSK;

		TCCR1A_REG |= TIMER1_MODE_PWM_PHASE_FREQUENCY_CORRECT_A_MSK;
		TCCR1B_REG |= TIMER1_MODE_PWM_PHASE_FREQUENCY_CORRECT_B_MSK;
		break;
	case TIMER1_MODE_PWM_PHASE_CORRECT_MSK:
		TCCR1A_REG &= TIMER1_MODE_clr_A_MSK;
		TCCR1B_REG &= TIMER1_MODE_clr_B_MSK;

		TCCR1A_REG |= TIMER1_MODE_PWM_PHASE_CORRECT_A_MSK;
		TCCR1B_REG |= TIMER1_MODE_PWM_PHASE_CORRECT_B_MSK;
		break;
	case TIMER1_MODE_FAST_PWM_MSK:
		TCCR1A_REG &= TIMER1_MODE_clr_A_MSK;
		TCCR1B_REG &= TIMER1_MODE_clr_B_MSK;

		TCCR1A_REG |= TIMER1_MODE_FAST_PWM_A_MSK;
		TCCR1B_REG |= TIMER1_MODE_FAST_PWM_B_MSK;
		break;
	}

#if (TIMER1_MODE_SELECTOR == TIMER1_MODE_CTC_MSK) || (TIMER1_MODE_SELECTOR == TIMER1_MODE_OVF_MSK)
#if TIMER1_OC1A_SELECT == ENABLE
	GPIO_SetPinDir(TIMER1_OC1A_PORT, TIMER1_OC1A_Pin, pin_output);
#if TIMER1_OC1_BEHAVIOR_SELECTOR == TIMER1_OC1_TOGGLE_MSK
	TCCR1A_REG &= TIMER1_OC1A_clr_MSK;
	TCCR1A_REG |= TIMER1_OC1A_TOGGLE_MSK;
#elif TIMER1_OC1_BEHAVIOR_SELECTOR == TIMER1_OC1_CLR_MSK
	TCCR1A_REG &= TIMER1_OC1A_clr_MSK;
	TCCR1A_REG |= TIMER1_OC1A_CLR_MSK;
#elif TIMER1_OC1_BEHAVIOR_SELECTOR == TIMER1_OC1_SET_MSK
	TCCR1A_REG &= TIMER1_OC1A_clr_MSK;
	TCCR1A_REG |= TIMER1_OC1A_SET_MSK;
#endif
#endif

#if TIMER1_OC1B_SELECT == ENABLE
	GPIO_SetPinDir(TIMER1_OC1B_PORT, TIMER1_OC1B_Pin, pin_output);
#if TIMER1_OC1_BEHAVIOR_SELECTOR == TIMER1_OC1_TOGGLE_MSK
	TCCR1A_REG &= TIMER1_OC1B_clr_MSK;
	TCCR1A_REG |= TIMER1_OC1B_TOGGLE_MSK;
#elif TIMER1_OC1_BEHAVIOR_SELECTOR == TIMER1_OC1_CLR_MSK
	TCCR1A_REG &= TIMER1_OC1B_clr_MSK;
	TCCR1A_REG |= TIMER1_OC1B_CLR_MSK;
#elif TIMER1_OC1_BEHAVIOR_SELECTOR == TIMER1_OC1_SET_MSK
	TCCR1A_REG &= TIMER1_OC1B_clr_MSK;
	TCCR1A_REG |= TIMER1_OC1B_SET_MSK;
#endif
#endif

#endif

#if (TIMER1_MODE_SELECTOR == TIMER1_MODE_PWM_PHASECORRECT_8_BIT_MSK)         \
	|| (TIMER1_MODE_SELECTOR == TIMER1_MODE_PWM_PHASECORRECT_9_BIT_MSK)      \
	|| (TIMER1_MODE_SELECTOR == TIMER1_MODE_PWM_PHASECORRECT_10_BIT_MSK)     \
	|| (TIMER1_MODE_SELECTOR == TIMER1_MODE_PWM_PHASE_FREQUENCY_CORRECT_MSK) \
	|| (TIMER1_MODE_SELECTOR == TIMER1_MODE_PWM_PHASE_CORRECT_MSK)

#if TIMER1_OC1A_SELECT == ENABLE
	GPIO_SetPinDir(TIMER1_OC1A_PORT, TIMER1_OC1A_Pin, pin_output);
#if TIMER1_OC1_BEHAVIOR_SELECTOR == TIMER1_OC1_NON_INVERTING_MSK
	TCCR1A_REG &= TIMER1_OC1A_clr_MSK;
	TCCR1A_REG |= TIMER1_OC1A_NON_INVERTING_MSK;
#elif TIMER1_OC1_BEHAVIOR_SELECTOR == TIMER1_OC1_INVERTING_MSK
	TCCR1A_REG &= TIMER1_OC1A_clr_MSK;
	TCCR1A_REG |= TIMER1_OC1A_INVERTING_MSK;
#elif TIMER1_OC1_BEHAVIOR_SELECTOR == TIMER1_OC1_SPECIAL_TOGGLE_PHASE_CORRECT_MSK
	TCCR1A_REG &= TIMER1_OC1A_clr_MSK;
	TCCR1A_REG |= TIMER1_OC1A_SPECIAL_TOGGLE_PHASE_CORRECT_MSK;
#endif
#endif

#if TIMER1_OC1B_SELECT == ENABLE
	GPIO_SetPinDir(TIMER1_OC1B_PORT, TIMER1_OC1B_Pin, pin_output);
#if TIMER1_OC1_BEHAVIOR_SELECTOR == TIMER1_OC1_NON_INVERTING_MSK
	TCCR1A_REG &= TIMER1_OC1B_clr_MSK;
	TCCR1A_REG |= TIMER1_OC1B_NON_INVERTING_MSK;
#elif TIMER1_OC1_BEHAVIOR_SELECTOR == TIMER1_OC1_INVERTING_MSK
	TCCR1A_REG &= TIMER1_OC1B_clr_MSK;
	TCCR1A_REG |= TIMER1_OC1B_INVERTING_MSK;
#elif TIMER1_OC1_BEHAVIOR_SELECTOR == TIMER1_OC1_SPECIAL_TOGGLE_PHASE_CORRECT_MSK
	TCCR1A_REG &= TIMER1_OC1B_clr_MSK;
	TCCR1A_REG |= TIMER1_OC1B_SPECIAL_TOGGLE_PHASE_CORRECT_MSK;
#endif
#endif


#endif

#if (TIMER1_MODE_SELECTOR == TIMER1_MODE_FASTPWM_8_BIT_MSK)   \
	|| (TIMER1_MODE_SELECTOR == TIMER1_MODE_FASTPWM_9_BIT_MSK)  \
	|| (TIMER1_MODE_SELECTOR == TIMER1_MODE_FASTPWM_10_BIT_MSK) \
	|| (TIMER1_MODE_SELECTOR == TIMER1_MODE_FAST_PWM_MSK)

#if TIMER1_OC1A_SELECT == ENABLE
	GPIO_SetPinDir(TIMER1_OC1A_PORT, TIMER1_OC1A_Pin, pin_output);
#if TIMER1_OC1_BEHAVIOR_SELECTOR == TIMER1_OC1_NON_INVERTING_MSK
	TCCR1A_REG &= TIMER1_OC1A_clr_MSK;
	TCCR1A_REG |= TIMER1_OC1A_NON_INVERTING_MSK;
#elif TIMER1_OC1_BEHAVIOR_SELECTOR == TIMER1_OC1_INVERTING_MSK
	TCCR1A_REG &= TIMER1_OC1A_clr_MSK;
	TCCR1A_REG |= TIMER1_OC1A_INVERTING_MSK;
#elif TIMER1_OC1_BEHAVIOR_SELECTOR == TIMER1_OC1_SPECIAL_TOGGLE_FASTPWM_MSK
	TCCR1A_REG &= TIMER1_OC1A_clr_MSK;
	TCCR1A_REG |= TIMER1_OC1A_SPECIAL_TOGGLE_FASTPWM_MSK;
#endif
#endif

#if TIMER1_OC1B_SELECT == ENABLE
	GPIO_SetPinDir(TIMER1_OC1B_PORT, TIMER1_OC1B_Pin, pin_output);
#if TIMER1_OC1_BEHAVIOR_SELECTOR == TIMER1_OC1_NON_INVERTING_MSK
	TCCR1A_REG &= TIMER1_OC1B_clr_MSK;
	TCCR1A_REG |= TIMER1_OC1B_NON_INVERTING_MSK;
#elif TIMER1_OC1_BEHAVIOR_SELECTOR == TIMER1_OC1_INVERTING_MSK
	TCCR1A_REG &= TIMER1_OC1B_clr_MSK;
	TCCR1A_REG |= TIMER1_OC1B_INVERTING_MSK;
#elif TIMER1_OC1_BEHAVIOR_SELECTOR == TIMER1_OC1_SPECIAL_TOGGLE_FASTPWM_MSK
	TCCR1A_REG &= TIMER1_OC1B_clr_MSK;
	TCCR1A_REG |= TIMER1_OC1B_SPECIAL_TOGGLE_FASTPWM_MSK;
#endif
#endif


#endif

	switch(TIMER1_PRESCALER_SELECTOR)
	{
	case TIMER1_CLK_WITH_NO_PRESCALER_MSK:
		TCCR1B_REG &= TIMER1_CLK_WITH_PRESCALER_clr_MSK;
		TCCR1B_REG |= TIMER1_CLK_WITH_NO_PRESCALER_MSK;
		break;
	case TIMER1_CLK_WITH_8_PRESCALER_MSK:
		TCCR1B_REG &= TIMER1_CLK_WITH_PRESCALER_clr_MSK;
		TCCR1B_REG |= TIMER1_CLK_WITH_8_PRESCALER_MSK;
		break;
	case TIMER1_CLK_WITH_64_PRESCALER_MSK:
		TCCR1B_REG &= TIMER1_CLK_WITH_PRESCALER_clr_MSK;
		TCCR1B_REG |= TIMER1_CLK_WITH_64_PRESCALER_MSK;
		break;
	case TIMER1_CLK_WITH_256_PRESCALER_MSK:
		TCCR1B_REG &= TIMER1_CLK_WITH_PRESCALER_clr_MSK;
		TCCR1B_REG |= TIMER1_CLK_WITH_256_PRESCALER_MSK;
		break;
	case TIMER1_CLK_WITH_1024_PRESCALER_MSK:
		TCCR1B_REG &= TIMER1_CLK_WITH_PRESCALER_clr_MSK;
		TCCR1B_REG |= TIMER1_CLK_WITH_1024_PRESCALER_MSK;
		break;
	case TIMER1_EXTERNAL_CLK_WITH_FALLING_EDGE_MSK:
		TCCR1B_REG &= TIMER1_CLK_WITH_PRESCALER_clr_MSK;
		TCCR1B_REG |= TIMER1_EXTERNAL_CLK_WITH_FALLING_EDGE_MSK;
		break;
	case TIMER1_EXTERNAL_CLK_WITH_RISING_EDGE_MSK:
		TCCR1B_REG &= TIMER1_CLK_WITH_PRESCALER_clr_MSK;
		TCCR1B_REG |= TIMER1_EXTERNAL_CLK_WITH_RISING_EDGE_MSK;
		break;
	}

	/* Initial value for Timer/Counter1 */
	TCNT1_REG = TIMER1_INITIAL_VALUE;

	/* Compare value for Timer/Counter0 */
	OCR1A_REG = TIMER1_COMPARE_A_VALUE;
	OCR1B_REG = TIMER1_COMPARE_B_VALUE;
#endif

#if TIMER2 == ENABLE
#if (TIMER2_MODE_SELECTOR == TIMER2_MODE_PWM_PHASECORRECT_MSK) || (TIMER2_MODE_SELECTOR == TIMER2_MODE_FASTPWM_MSK)
#if (TIMER2_MODE_SELECTOR == TIMER2_MODE_PWM_PHASECORRECT_MSK)
	TCCR2_REG &= TIMER2_MODE_clr_MSK;
	TCCR2_REG |= TIMER2_MODE_PWM_PHASECORRECT_MSK;
#elif (TIMER2_MODE_SELECTOR == TIMER2_MODE_FASTPWM_MSK)
	TCCR2_REG &= TIMER2_MODE_clr_MSK;
	TCCR2_REG |= TIMER2_MODE_FASTPWM_MSK;
#endif

#if TIMER2_OC2_BEHAVIOR_SELECTOR == TIMER2_OC2_NON_INVERTING_MSK
	TCCR2_REG &= TIMER2_OC2_clr_MSK;
	GPIO_SetPinDir(TIMER2_OC2_PORT, TIMER2_OC2_Pin, pin_output);
	TCCR2_REG |= TIMER2_OC2_NON_INVERTING_MSK;
#elif TIMER2_OC2_BEHAVIOR_SELECTOR == TIMER2_OC2_INVERTING_MSK
	TCCR2_REG &= TIMER2_OC2_clr_MSK;
	GPIO_SetPinDir(TIMER2_OC2_PORT, TIMER2_OC2_Pin, pin_output);
	TCCR2_REG |= TIMER2_OC2_INVERTING_MSK;
#endif
#endif

#if (TIMER2_MODE_SELECTOR == TIMER2_MODE_OVF_MSK) || (TIMER2_MODE_SELECTOR == TIMER2_MODE_CTC_MSK)
#if TIMER2_MODE_SELECTOR == TIMER2_MODE_OVF_MSK
	TCCR2_REG &= TIMER2_OC2_clr_MSK;
	TCCR2_REG |= TIMER2_MODE_OVF_MSK;
#elif TIMER2_MODE_SELECTOR == TIMER2_MODE_CTC_MSK
	TCCR2_REG &= TIMER2_OC2_clr_MSK;
	TCCR2_REG |= TIMER2_MODE_CTC_MSK;
#endif

#if TIMER2_OC2_BEHAVIOR_SELECTOR == TIMER2_OC2_TOGGLE_MSK
	TCCR2_REG &= TIMER2_OC2_clr_MSK;
	GPIO_SetPinDir(TIMER2_OC2_PORT, TIMER2_OC2_Pin, pin_output);
	TCCR2_REG |= TIMER2_OC2_TOGGLE_MSK;
#elif TIMER2_OC2_BEHAVIOR_SELECTOR == TIMER2_OC2_CLR_MSK
	TCCR2_REG &= TIMER2_OC2_clr_MSK;
	GPIO_SetPinDir(TIMER2_OC2_PORT, TIMER2_OC2_Pin, pin_output);
	TCCR2_REG |= TIMER2_OC2_CLR_MSK;
#elif TIMER2_OC2_BEHAVIOR_SELECTOR == TIMER2_OC2_SET_MSK
	TCCR2_REG &= TIMER2_OC2_clr_MSK;
	GPIO_SetPinDir(TIMER2_OC2_PORT, TIMER2_OC2_Pin, pin_output);
	TCCR2_REG |= TIMER2_OC2_SET_MSK;
#endif
#endif

	switch(TIMER2_PRESCALER_SELECTOR)
	{
	case TIMER2_CLK_WITH_NO_PRESCALER_MSK:
		TCCR2_REG &= TIMER2_CLK_WITH_PRESCALER_clr_MSK;
		TCCR2_REG |= TIMER2_CLK_WITH_NO_PRESCALER_MSK;
		break;
	case TIMER2_CLK_WITH_8_PRESCALER_MSK:
		TCCR2_REG &= TIMER2_CLK_WITH_PRESCALER_clr_MSK;
		TCCR2_REG |= TIMER2_CLK_WITH_8_PRESCALER_MSK;
		break;
	case TIMER2_CLK_WITH_32_PRESCALER_MSK:
		TCCR2_REG &= TIMER2_CLK_WITH_PRESCALER_clr_MSK;
		TCCR2_REG |= TIMER2_CLK_WITH_32_PRESCALER_MSK;
		break;
	case TIMER2_CLK_WITH_64_PRESCALER_MSK:
		TCCR2_REG &= TIMER2_CLK_WITH_PRESCALER_clr_MSK;
		TCCR2_REG |= TIMER2_CLK_WITH_64_PRESCALER_MSK;
		break;
	case TIMER2_CLK_WITH_128_PRESCALER_MSK:
		TCCR2_REG &= TIMER2_CLK_WITH_PRESCALER_clr_MSK;
		TCCR2_REG |= TIMER2_CLK_WITH_128_PRESCALER_MSK;
		break;
	case TIMER2_CLK_WITH_256_PRESCALER_MSK:
		TCCR2_REG &= TIMER2_CLK_WITH_PRESCALER_clr_MSK;
		TCCR2_REG |= TIMER2_CLK_WITH_256_PRESCALER_MSK;
		break;
	case TIMER2_CLK_WITH_1024_PRESCALER_MSK:
		TCCR2_REG &= TIMER2_CLK_WITH_PRESCALER_clr_MSK;
		TCCR2_REG |= TIMER2_CLK_WITH_1024_PRESCALER_MSK;
		break;
	}

	/* Initial value for Timer/Counter2 */
	TCNT2_REG = TIMER2_INITIAL_VALUE;

	/* Compare value for Timer/Counter2 */
	OCR2_REG = TIMER2_COMPARE_VALUE;
#endif

	/* To enable TIMER's Interrupt */
	TIMER_EnableInterrupt();
}

/*
 * [FUNCTION NAME]: TIMER_EnableInterrupt
 * [DISCRIPTION]  : This function is responsible to Enable The required Type of Interrupt
 *                  Depend on Timer That you made it Enable.
 * [Args]  : void
 * [RUTURN]: Void
 */
void TIMER_EnableInterrupt(void)
{
#if TIMER0 == ENABLE

#if TIMER0_OVF_INT_EN == ENABLE
	SET_BIT(TIMSK_REG,TIMSK_TOIE0);
#elif TIMER0_COMP_INT_EN == ENABLE
	SET_BIT(TIMSK_REG,TIMSK_OCIE0);
#endif
#endif

#if TIMER1 == ENABLE

#if TIMER1_OVF_INT_EN == ENABLE
	SET_BIT(TIMSK_REG,TIMSK_TOIE1);
#elif TIMER1_COMPA_INT_EN == ENABLE
	SET_BIT(TIMSK_REG,TIMSK_OCIE1A);
#elif TIMER1_COMPb_INT_EN == ENABLE
	SET_BIT(TIMSK_REG,TIMSK_OCIE1B);
#endif
#endif

#if TIMER2 == ENABLE

#if TIMER2_OVF_INT_EN == ENABLE
	SET_BIT(TIMSK_REG,TIMSK_TOIE2);
#elif TIMER2_COMP_INT_EN == ENABLE
	SET_BIT(TIMSK_REG,TIMSK_OCIE2);
#endif
#endif
}

/*
 * [FUNCTION NAME]: TIMER_SetCallBack
 * [DISCRIPTION]  : This function's is responsible to set the Call Back function address.
 *                  Every set callback function follow specific Timer.
 * [Args]  : Pointer To Function take void and return void
 * [RUTURN]: Void
 */
void TIMER0_SetCallBack(void (*Ptr_To_fun)(void))
{
	g_Ptr_To_Fun_TIMER_0 = (volatile void *)Ptr_To_fun;
}

void TIMER1_SetCallBack(void (*Ptr_To_fun)(void))
{
	g_Ptr_To_Fun_TIMER_1 = (volatile void *)Ptr_To_fun;
}

void TIMER2_SetCallBack(void (*Ptr_To_fun)(void))
{
	g_Ptr_To_Fun_TIMER_2 = (volatile void *)Ptr_To_fun;
}

/*
 * [FUNCTION NAME]: TIMER_DeInit
 * [DISCRIPTION]  : This function is responsible to De-initialization all Timers
 * [Args]  : void
 * [RUTURN]: Void
 */
void TIMER_DeInit(void)
{
	/* TIMER0 De-init */
	TCCR0_REG = 0;
	/* TIMER2 De-init */
	TCCR2_REG = 0;

	/* TIMER1 De-init */
	TCCR1A_REG = 0;
	TCCR1B_REG = 0;
}

/*
 * [FUNCTION NAME]: Timer0_PWM_DutyCycle
 * [DISCRIPTION]  :  Initialize the PWM module by:
 * 					 1. Trigger Timer0 with
 * 					 	TIMER0_MODE_FASTPWM_MSK.
 * 					 	TIMER0_MODE_PWM_PHASECORRECT_MSK
 *					 2. Setup the PWM behavior.
 *					 3. Setup the prescaler.
 *					 4. Setup the compare value based on the required input duty cycle.
 *					 5. Setup the direction for OC0 as output pin.
 * [Args]  : required input duty cycle
 * [RUTURN]: Void
 */
void Timer0_PWM_DutyCycle(uint8 duty_cycle)
{
	/* Initial value for Timer/Counter0 */
	TCNT0_REG = TIMER0_INITIAL_VALUE;

	/* Set Compare value */
	OCR0_REG = ((float32)duty_cycle / 100) * 255;

#if (TIMER0_MODE_SELECTOR == TIMER0_MODE_PWM_PHASECORRECT_MSK)
	TCCR0_REG &= TIMER0_MODE_clr_MSK;
	TCCR0_REG |= TIMER0_MODE_PWM_PHASECORRECT_MSK;
#elif (TIMER0_MODE_SELECTOR == TIMER0_MODE_FASTPWM_MSK)
	TCCR0_REG &= TIMER0_MODE_clr_MSK;
	TCCR0_REG |= TIMER0_MODE_FASTPWM_MSK;
#endif

#if TIMER0_OC0_BEHAVIOR_SELECTOR == TIMER0_OC0_NON_INVERTING_MSK
	TCCR0_REG &= TIMER0_OC0_clr_MSK;
	GPIO_SetPinDir(TIMER0_OC0_PORT, TIMER0_OC0_Pin, pin_output);
	TCCR0_REG |= TIMER0_OC0_NON_INVERTING_MSK;
#elif TIMER0_OC0_BEHAVIOR_SELECTOR == TIMER0_OC0_INVERTING_MSK
	TCCR0_REG &= TIMER0_OC0_clr_MSK;
	GPIO_SetPinDir(TIMER0_OC0_PORT, TIMER0_OC0_Pin, pin_output);
	TCCR0_REG |= TIMER0_OC0_INVERTING_MSK;
#endif

	switch(TIMER0_PRESCALER_SELECTOR)
	{
	case TIMER0_CLK_WITH_NO_PRESCALER_MSK:
		TCCR0_REG &= TIMER0_CLK_WITH_PRESCALER_clr_MSK;
		TCCR0_REG |= TIMER0_CLK_WITH_NO_PRESCALER_MSK;
		break;
	case TIMER0_CLK_WITH_8_PRESCALER_MSK:
		TCCR0_REG &= TIMER0_CLK_WITH_PRESCALER_clr_MSK;
		TCCR0_REG |= TIMER0_CLK_WITH_8_PRESCALER_MSK;
		break;
	case TIMER0_CLK_WITH_64_PRESCALER_MSK:
		TCCR0_REG &= TIMER0_CLK_WITH_PRESCALER_clr_MSK;
		TCCR0_REG |= TIMER0_CLK_WITH_64_PRESCALER_MSK;
		break;
	case TIMER0_CLK_WITH_256_PRESCALER_MSK:
		TCCR0_REG &= TIMER0_CLK_WITH_PRESCALER_clr_MSK;
		TCCR0_REG |= TIMER0_CLK_WITH_256_PRESCALER_MSK;
		break;
	case TIMER0_CLK_WITH_1024_PRESCALER_MSK:
		TCCR0_REG &= TIMER0_CLK_WITH_PRESCALER_clr_MSK;
		TCCR0_REG |= TIMER0_CLK_WITH_1024_PRESCALER_MSK;
		break;
	case TIMER0_EXTERNAL_CLK_WITH_FALLING_EDGE_MSK:
		TCCR0_REG &= TIMER0_CLK_WITH_PRESCALER_clr_MSK;
		TCCR0_REG |= TIMER0_EXTERNAL_CLK_WITH_FALLING_EDGE_MSK;
		break;
	case TIMER0_EXTERNAL_CLK_WITH_RISING_EDGE_MSK:
		TCCR0_REG &= TIMER0_CLK_WITH_PRESCALER_clr_MSK;
		TCCR0_REG |= TIMER0_EXTERNAL_CLK_WITH_RISING_EDGE_MSK;
		break;
	}
}

/*
 * [FUNCTION NAME]: Timer1_PWM_DutyCycle
 * [DISCRIPTION]  :  Initialize the PWM module by:
 * 					 1. Trigger Timer1 with
 * 					 	TIMER1_MODE_FAST_PWM_MSK.
 * 					 	TIMER1_MODE_PWM_PHASE_CORRECT_MSK
 *					 2. Setup the PWM behavior.
 *					 3. Setup the prescaler.
 *					 4. Setup the compare value based on the required input duty cycle.
 *					 5. Setup the direction for OC1B as output pin.
 * [Args]  : required input duty cycle
 * [RUTURN]: Void
 */
void Timer1_PWM_DutyCycle(uint16  duty_cycle)
{
	/* Initial value for Timer/Counter1 */
	TCNT1_REG = TIMER1_INITIAL_VALUE;
	/*
	 * use fast mode with top value at OCRA reg
	 * diconnect OC1A PIN ,and generate the PWM on OC1B PIN
	 */
	/* Compare value for Timer/Counter0 */
	OCR1A_REG = TIMER1_COMPARE_A_VALUE;
	OCR1B_REG = ((float32)duty_cycle / 100) * 65535;

#if TIMER1_MODE_SELECTOR == TIMER1_MODE_PWM_PHASE_CORRECT_MSK
	TCCR1A_REG &= TIMER1_MODE_clr_A_MSK;
	TCCR1B_REG &= TIMER1_MODE_clr_B_MSK;

	TCCR1A_REG |= TIMER1_MODE_PWM_PHASE_CORRECT_A_MSK;
	TCCR1B_REG |= TIMER1_MODE_PWM_PHASE_CORRECT_B_MSK;
#elif TIMER1_MODE_SELECTOR ==TIMER1_MODE_FAST_PWM_MSK
	TCCR1A_REG &= TIMER1_MODE_clr_A_MSK;
	TCCR1B_REG &= TIMER1_MODE_clr_B_MSK;

	TCCR1A_REG |= TIMER1_MODE_FAST_PWM_A_MSK;
	TCCR1B_REG |= TIMER1_MODE_FAST_PWM_B_MSK;
#endif

#if TIMER1_OC1B_SELECT == ENABLE
	GPIO_SetPinDir(TIMER1_OC1B_PORT, TIMER1_OC1B_Pin, pin_output);
#if TIMER1_OC1_BEHAVIOR_SELECTOR == TIMER1_OC1_NON_INVERTING_MSK
	TCCR1A_REG &= TIMER1_OC1B_clr_MSK;
	TCCR1A_REG |= TIMER1_OC1B_NON_INVERTING_MSK;
#elif TIMER1_OC1_BEHAVIOR_SELECTOR == TIMER1_OC1_INVERTING_MSK
	TCCR1A_REG &= TIMER1_OC1B_clr_MSK;
	TCCR1A_REG |= TIMER1_OC1B_INVERTING_MSK;
#elif TIMER1_OC1_BEHAVIOR_SELECTOR == TIMER1_OC1_SPECIAL_TOGGLE_FASTPWM_MSK
	TCCR1A_REG &= TIMER1_OC1B_clr_MSK;
	TCCR1A_REG |= TIMER1_OC1B_SPECIAL_TOGGLE_FASTPWM_MSK;
#elif TIMER1_OC1_BEHAVIOR_SELECTOR == TIMER1_OC1_SPECIAL_TOGGLE_PHASE_CORRECT_MSK
	TCCR1A_REG &= TIMER1_OC1B_clr_MSK;
	TCCR1A_REG |= TIMER1_OC1B_SPECIAL_TOGGLE_PHASE_CORRECT_MSK;
#endif
#endif

	switch(TIMER1_PRESCALER_SELECTOR)
	{
	case TIMER1_CLK_WITH_NO_PRESCALER_MSK:
		TCCR1B_REG &= TIMER1_CLK_WITH_PRESCALER_clr_MSK;
		TCCR1B_REG |= TIMER1_CLK_WITH_NO_PRESCALER_MSK;
		break;
	case TIMER1_CLK_WITH_8_PRESCALER_MSK:
		TCCR1B_REG &= TIMER1_CLK_WITH_PRESCALER_clr_MSK;
		TCCR1B_REG |= TIMER1_CLK_WITH_8_PRESCALER_MSK;
		break;
	case TIMER1_CLK_WITH_64_PRESCALER_MSK:
		TCCR1B_REG &= TIMER1_CLK_WITH_PRESCALER_clr_MSK;
		TCCR1B_REG |= TIMER1_CLK_WITH_64_PRESCALER_MSK;
		break;
	case TIMER1_CLK_WITH_256_PRESCALER_MSK:
		TCCR1B_REG &= TIMER1_CLK_WITH_PRESCALER_clr_MSK;
		TCCR1B_REG |= TIMER1_CLK_WITH_256_PRESCALER_MSK;
		break;
	case TIMER1_CLK_WITH_1024_PRESCALER_MSK:
		TCCR1B_REG &= TIMER1_CLK_WITH_PRESCALER_clr_MSK;
		TCCR1B_REG |= TIMER1_CLK_WITH_1024_PRESCALER_MSK;
		break;
	case TIMER1_EXTERNAL_CLK_WITH_FALLING_EDGE_MSK:
		TCCR1B_REG &= TIMER1_CLK_WITH_PRESCALER_clr_MSK;
		TCCR1B_REG |= TIMER1_EXTERNAL_CLK_WITH_FALLING_EDGE_MSK;
		break;
	case TIMER1_EXTERNAL_CLK_WITH_RISING_EDGE_MSK:
		TCCR1B_REG &= TIMER1_CLK_WITH_PRESCALER_clr_MSK;
		TCCR1B_REG |= TIMER1_EXTERNAL_CLK_WITH_RISING_EDGE_MSK;
		break;
	}
}


/*
 * [FUNCTION NAME]: Timer2_PWM_DutyCycle
 * [DISCRIPTION]  :  Initialize the PWM module by:
 * 					 1. Trigger Timer0 with
 * 					 	TIMER2_MODE_FASTPWM_MSK.
 * 					 	TIMER2_MODE_PWM_PHASECORRECT_MSK
 *					 2. Setup the PWM behavior.
 *					 3. Setup the prescaler.
 *					 4. Setup the compare value based on the required input duty cycle.
 *					 5. Setup the direction for OCR2 as output pin.
 * [Args]  : required input duty cycle
 * [RUTURN]: Void
 */
void Timer2_PWM_DutyCycle(uint8 duty_cycle)
{

	/* Initial value for Timer/Counter2 */
	TCNT2_REG = TIMER2_INITIAL_VALUE;

	/* Compare value for Timer/Counter2 */
	OCR2_REG = ((float32)duty_cycle / 100) * 255;

#if (TIMER2_MODE_SELECTOR == TIMER2_MODE_PWM_PHASECORRECT_MSK)
	TCCR2_REG &= TIMER2_MODE_clr_MSK;
	TCCR2_REG |= TIMER2_MODE_PWM_PHASECORRECT_MSK;
#elif (TIMER2_MODE_SELECTOR == TIMER2_MODE_FASTPWM_MSK)
	TCCR2_REG &= TIMER2_MODE_clr_MSK;
	TCCR2_REG |= TIMER2_MODE_FASTPWM_MSK;
#endif

#if TIMER2_OC2_BEHAVIOR_SELECTOR == TIMER2_OC2_NON_INVERTING_MSK
	TCCR2_REG &= TIMER2_OC2_clr_MSK;
	GPIO_SetPinDir(TIMER2_OC2_PORT, TIMER2_OC2_Pin, pin_output);
	TCCR2_REG |= TIMER2_OC2_NON_INVERTING_MSK;
#elif TIMER2_OC2_BEHAVIOR_SELECTOR == TIMER2_OC2_INVERTING_MSK
	TCCR2_REG &= TIMER2_OC2_clr_MSK;
	GPIO_SetPinDir(TIMER2_OC2_PORT, TIMER2_OC2_Pin, pin_output);
	TCCR2_REG |= TIMER2_OC2_INVERTING_MSK;
#endif

	switch(TIMER2_PRESCALER_SELECTOR)
	{
	case TIMER2_CLK_WITH_NO_PRESCALER_MSK:
		TCCR2_REG &= TIMER2_CLK_WITH_PRESCALER_clr_MSK;
		TCCR2_REG |= TIMER2_CLK_WITH_NO_PRESCALER_MSK;
		break;
	case TIMER2_CLK_WITH_8_PRESCALER_MSK:
		TCCR2_REG &= TIMER2_CLK_WITH_PRESCALER_clr_MSK;
		TCCR2_REG |= TIMER2_CLK_WITH_8_PRESCALER_MSK;
		break;
	case TIMER2_CLK_WITH_32_PRESCALER_MSK:
		TCCR2_REG &= TIMER2_CLK_WITH_PRESCALER_clr_MSK;
		TCCR2_REG |= TIMER2_CLK_WITH_32_PRESCALER_MSK;
		break;
	case TIMER2_CLK_WITH_64_PRESCALER_MSK:
		TCCR2_REG &= TIMER2_CLK_WITH_PRESCALER_clr_MSK;
		TCCR2_REG |= TIMER2_CLK_WITH_64_PRESCALER_MSK;
		break;
	case TIMER2_CLK_WITH_128_PRESCALER_MSK:
		TCCR2_REG &= TIMER2_CLK_WITH_PRESCALER_clr_MSK;
		TCCR2_REG |= TIMER2_CLK_WITH_128_PRESCALER_MSK;
		break;
	case TIMER2_CLK_WITH_256_PRESCALER_MSK:
		TCCR2_REG &= TIMER2_CLK_WITH_PRESCALER_clr_MSK;
		TCCR2_REG |= TIMER2_CLK_WITH_256_PRESCALER_MSK;
		break;
	case TIMER2_CLK_WITH_1024_PRESCALER_MSK:
		TCCR2_REG &= TIMER2_CLK_WITH_PRESCALER_clr_MSK;
		TCCR2_REG |= TIMER2_CLK_WITH_1024_PRESCALER_MSK;
		break;
	}
}
